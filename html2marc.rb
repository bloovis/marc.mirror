#!/usr/bin/env ruby

# This script reads a web page, either a local file or a URL, that should be
# the page that is produced when you do one of the following:
#  - In an Evergreen (CWMARS, GAPINES, etc.) detail page for a book, right click on
#    the "Bibliographic Record" link, and select "Copy Link".  Pass that link
#    to this script.
#  - In a BiblioCommons (Boston Public Library, Chicago Public Library) detail page
#    for a book, click on "Full Record" tab, then on the "MARC Display" Link.
#    Right click over the MARC display, and select "Save Page As", then "Web Page, Complete"
#    in the resulting dialog, then save the page to an HTML file.  Pass the full
#    path of the HTML file to this script.
#  - In an OCLC Connexion detail page for a book, click on the "MARC Display" link,
#    then right click over the MARC display, and select "This Frame", then "Save Frame As",
#    then "Web Page, Complete" in the resulting dialog, then save the page to an HTML file.
#    Pass the full path of the HTML file to this script.

begin
  require 'marc'
rescue LoadError => exc
  puts "Exception trying to load marc gem: #{exc}"
  puts "Try doing this first:"
  puts "  sudo gem install marc"
  exit 1
end
require 'date'

verbose = false   	# Change to true print some debugging info
overwrite = false	# Can be set to true by -o option

class Converter

private

  def dprint(str)
    if @verbose
      puts str
    end
  end

  # Convert some HTML entities into their ASCII equivalents.

  def fixentities(s)
    return s.gsub(/&apos;/, "'").gsub(/&amp;?/, '&').gsub(/&quot;/, '"').gsub(/&nbsp;/, ' ')
  end

public

  def initialize(filename, verbose=false)
    @verbose = verbose
    if filename =~ /^https?:/
      @handle = IO.popen(['wget', '-nv', '-O', '-', filename])
    elsif filename == "-"
      @handle = $stdin
    else
      @handle = File.open(filename)
    end

    # Collect all of the relevant table lines from the HTML
    @table = nil
    @kind = nil
    @handle.each do |line|
      if @table
	@table << line
        if line =~ /<\/table>/i
	  break
	end
      elsif line =~ /table class="marc_table"/
	@table = line
	@kind = :evergreen
      elsif line =~ /Dynamically Generated by catexpmarcrecord/
        @table = line
	@kind = :oclc
      elsif line =~ /div id=\"marc_details\">/
        @table = line
	@kind = :biblio
      end
    end
    unless @kind
      puts "Unrecognized HTML format.  Must be Evergreen, OCLC, or BiblioCommons."
      exit 1
    end
  end

  def write_marc_evergreen
    inds = nil
    tag_name = nil
    tag_value = nil
    rows = @table.split(/<\/?tr[^>]*>/)
    rows.each do |row|
      field = nil
      # puts "row: '#{row}'"
      if row =~ /\s*<th.*>(.*)<\/th>(.*)/m
        tag_name = $1.strip
	rest = $2
	dprint "tag_name: '#{tag_name}'"
	# puts "  rest: '#{rest}'"
	if rest =~ /(.*)<td class=\"marc_subfields\">(.*)<\/td>/m
	  ind = $1
	  tags = $2
	  # puts "  inds: '#{ind}'"
	  # puts "  tags: '#{tags}'"
	  indtds = ind.split(/<\/?td[^>]*>/)
	  inds = []
	  indtds.each do |i|
	    itext = i.gsub(/<span.*span>/, '')
	    if itext.length > 0
	      dprint "   ind: '#{itext}'"
	      inds << itext
	    end
	  end
	  if tag_name < '900'
	    field = MARC::DataField.new(tag_name, inds[0], inds[1])
	    texts = tags.split(/\s*<\/?span[^>]*>/)
	    texts.each_index do |i|
	      text = texts[i]
	      if text =~ /â€¡(.)/
		subfield_name = $1
		subfield_value = texts[i+1]
		dprint "   subfield: name: '#{subfield_name}', value: '#{subfield_value}'"
		subfield = MARC::Subfield.new(subfield_name, subfield_value)
		field.append(subfield)
	      end
	    end
	  end
	elsif rest =~ /\s*<td class=\"marc_tag_data\"[^>]*>(.*)<\/td>/m
	  tag_value = $1
	  if tag_name >= '000' && tag_name <= '009'
	    field = MARC::ControlField.new(tag_name, tag_value)
	  end
	end
      end
      if field
	@record.append(field)
      end
    end
  end

  def write_marc_biblio
    intable = false
    tag_value_partial = nil
    inds = nil
    tag_name = nil
    tag_value = nil
    lines = @table.split("\n")
    lines.each do |line|
      if line =~ /<div id=\"marc_details\">/
	intable = true
      elsif intable
        if line =~ /<\/table>/
	  break
        elsif line =~ /class=\"marcTag\"><strong>(\d+)/
	  tag_name = $1
	  dprint "Tag name: #{tag_name}"
        elsif line =~ /class=\"marcIndicator\">(..)/
	  inds = $1
	  dprint "  indicators: #{inds}"
        elsif line =~ /class=\"marcTagData\">(.+)<\/td>/
          tag_value = $1
          dprint "  tag value: #{tag_value}"
	elsif line =~ /class=\"marcTagData\">(.+)/
	  tag_value_partial = $1.strip
	  dprint "  tag value partial: #{tag_value_partial}"
	elsif line =~ /(.*)<\/td>$/
	  if tag_value_partial
	    tag_value = tag_value_partial + ' ' + $1
	    tag_value_partial = nil
	  end
	  dprint "  tag value: #{tag_value}"
        elsif tag_value_partial
	  tag_value_partial << ' ' + line.strip
	  dprint "  tag value partial: #{tag_value_partial}"
	end
	if inds && tag_name && tag_value
	  tag_value = fixentities(tag_value)
	  field = nil
	  if tag_name >= '000' && tag_name <= '009'
	    field = MARC::ControlField.new(tag_name, tag_value)
	  elsif tag_name < '900'
	    field = MARC::DataField.new(tag_name, inds[0], inds[1])
	    subfields = tag_value.split('$')
	    subfields.each do |subfield|
	      if subfield != ''
		subfield_name = subfield[0]
		subfield_value = subfield[1..-1]
		dprint "  tag subfield name: #{subfield_name}, value: #{subfield_value}"
		subfield = MARC::Subfield.new(subfield_name, subfield_value)
		field.append(subfield)
	      end
	    end
	  end
	  if field
	    @record.append(field)
	  end
	  inds = nil
	  tag_name = nil
	  tag_value = nil
	end
      end
    end
  end

  def write_marc_oclc
    control_number = nil

    inds = nil
    tag_name = nil
    tag_value = nil
    rows = @table.split(/<tr/i)
    rows.each do |row|
      tds = row.split(/<td/i)
      tds.each do |t|
        td = fixentities(t)
        case td
        when /catexTag/
	  if td =~ /<b>\n?([\d]+)(<\/font>)?<\/b>/i
	    tag_name = $1.strip
            dprint "Tag name: '#{tag_name}'"
	  end
	when /catexInds/
	  if td =~ /\">\n?(.*)<\/td/i
	    inds = $1
	    if inds[0] == "\n"
	      inds = inds[1..2]
	    else
	      inds = inds[0..1]
	    end
	    dprint "  td (inds): '#{td}'"
            dprint "  indicators: '#{inds}'"
	  end
	when /catexData/
	  dprint "  td (data): '#{td}'"
	  # t = td.gsub("\n", ' ').strip
	  if td =~ /\">(.*)<\/td/mi
	    tag_value = $1.gsub(/[\r\n]+$/, '').gsub("\n", ' ').gsub(/^\s+/, '')
            dprint "  tag value: '#{tag_value}'"
	  end
	end
	if inds && tag_name && tag_value
	  # It's necessary to strip out the non-breaking spaces
	  # from the tag value; otherwise, Koha will hang trying
	  # to display the resulting record in the MARC
	  # import tool.
	  tag_value = fixentities(tag_value)
	  field = nil
	  if tag_name >= '000' && tag_name <= '009'
	    if tag_name == '008'
	      field = MARC::ControlField.new('003', 'OCoLC')
	      @record.append(field)
	      now = DateTime.now
	      timestamp = now.strftime('%Y%m%d%H%M%S.0')
	      field = MARC::ControlField.new('005', timestamp)
	      @record.append(field)
	    end
	    if tag_name != '000'
	      dprint "ControlField: name: '#{tag_name}', value: '#{tag_value}'"
	      field = MARC::ControlField.new(tag_name, tag_value)
	      if tag_name == '001'
		control_number = tag_value
		dprint "  Control number = #{tag_value}"
	      end
	    end
	  else
	    if tag_name >= '043'
	      if control_number
		field = MARC::DataField.new('035', ' ', ' ')
		subfield = MARC::Subfield.new('a', '(OCoLC)' + control_number)
		field.append(subfield)
		@record.append(field)
		control_number = nil
	      end
	    end

	    # Need to split the data into subfields.  Example for 651:
	    #  Georgia (Republic)&nbsp;$x Description and travel.&nbsp;
	    # First subfield doesn't have a name; assumed to be $a.
	    field = MARC::DataField.new(tag_name, inds[0], inds[1])
	    subfields = tag_value.split('$')
	    subfields.each_with_index do |sub, i|
	      if sub.length > 0
		if i == 0
		  if sub[0] == '$'
		    subfield_name = sub[1]
		    subfield_value = sub[3..-1]
		  else
		    subfield_name = 'a'
		    subfield_value = sub
		  end
		else
		  subfield_name = sub[0]
		  subfield_value = sub[2..-1]
		end
		dprint "  subfield: name = '#{subfield_name}', value '#{subfield_value}'"
		if subfield_value
		  subfield = MARC::Subfield.new(subfield_name, subfield_value.strip)
		  field.append(subfield)
		else
		  puts "Tag #{tag_name}, subfield #{subfield_name} has a nil value"
		end
	      end
	    end
	  end
	  if field
	    @record.append(field)
	  end
	  inds = nil
	  tag_name = nil
	  tag_value = nil
	end
      end	# td.each
    end		# rows.each
  end

  def write_marc(output_file)
    @writer = MARC::Writer.new(output_file)
    dprint "MARC:"
    @record = MARC::Record.new()

    # Call the appropriate writer
    case @kind
    when :evergreen
      dprint "Converting Evergreen..."
      write_marc_evergreen
    when :oclc
      dprint "Converting OCLC..."
      write_marc_oclc
    when :biblio
      dprint "Converting BiblioCommons..."
      write_marc_biblio
    else
      puts "Unknown HTML format!"
    end

    @writer.write(@record)
    @writer.close
    @handle.close
  end

end

nopts = 0
ARGV.each do |arg|
  if arg == '-o'
    overwrite = true
    nopts += 1
  elsif arg == '-v'
    verbose = true
    nopts += 1
  else
    break
  end
end
ARGV.shift(nopts)

# Check arguments. First is input file.  Second is output file.
if ARGV.length < 2
   puts "usage: html2marc.rb [-o|-v] input-url-or-file MARC-output-file"
   puts "  -o : overwrite existing output file"
   puts "  -v : print verbose debugging information"
   exit 1
end

input_file = ARGV[0]
output_file = ARGV[1]

if !overwrite && File.exist?(output_file)
  puts "#{output_file} exists; will not overwrite."
  exit 1
end

c = Converter.new(input_file, verbose)
c.write_marc(output_file)
